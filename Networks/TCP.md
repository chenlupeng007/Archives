TCP 协议想要解决的一个问题就是双向通信, 也就是也就是双方都是发送方和接收方. 这就需要双方都知道彼此的 IP 和端口号. 在通信开始之前, 客户端知道通信双方的 IP 和端口号, 但是服务器却不知道. 另一个需要解决的问题是改变 UDP 这种只要有一个包丢失, 就要重发的低效特性, 使得通信变得更为可靠.

为此通信正式开始之前, 客户端和服务器准备好所需要的通信控制信息. 这个准备的过程需要经过所谓的"三次握手".

第一次握手: 客户端首先发送一个包, 这个包标头带有通信双方的端口号, 双方的 IP 地址则存在 IP 包的标头, SYN 设置为 1(告诉对方这是连接阶段, 相应的 Fin 为 1 则表示断开阶段); 还随机生成一个初始序列值 seq=x(相当于告诉对方数据开始于 x 处); ack=0(ack = y, 表示 y 之前的我都收到了); 客户端窗口值(告诉对方我的缓冲器还可容纳这么多字节).

第二次握手: 数据包到达服务器后, 服务器可以得到客户端的 IP, 端口, 序列初始值 seq, 窗口等信息. 然后构造一个 SYN = 1; seq = y(随机生成, 需要告知自己数据的初始位置, 因为双发都需要收发数据); ack = x+1(告诉对方 x+1 位置之前的我都收到了); 服务器窗口值. 并期待对方返回 ack = y+1 的包.

第三次握手: 这个包到达客户端后, 客户端就得到了服务器的序列初始值, 窗口号, 这样客户单所需的服务器的全部信息就都准备完毕了, 最后客户端返回 ack = y+1 的包, 并转入 established 状态. 如果这个包到达了服务器那么服务器也准备完成, 进入 established 状态. 
- seq = x 的包发出后, 如果没有收到一个 ack > x 的包, 会重发几次, 尝试几次后不行, 套接字返回请求失败.
- 如果收到 ack = x 的包, 那么之后接收到 seq < x 的包则会丢弃, 这样就不用担心重发的包到达.

连接创建好了, 则进入通信阶段. 应用程序调用 write(), 把数据交给协议栈发送, 读取数据则是 read() 函数.

一般 web 服务器在知道客户端已经接收到全部相应后, 调用 close() 进入断开阶段. 断开则经历了四次
挥手. 整个过程如下图:

<center>
  <img src='./TCP.png' >
</center>

TCP三次握手的第三次的 ack包丢失会怎样?
服务端: 第三次的 ACK 在网络中丢失, 那么服务端的 TCP 连接状态为 SYN_RECV, 并且会根据 TCP 的超时重传机制, 会等待3秒, 6秒, 12秒后重新发送 SYN+ACK包, 以便客户重新发送 ACK 包. 如果重发指定次数之后, 仍然未收到客户端的 ACK 应答, 那么一段时间后, 服务端自动关闭这个连接.

客户端: 在 linux 中客户端一般是通过 connect() 函数来连接服务器的, 而 connect()是在 TCP 的三次握手的第二次握手完成后就成功返回值. 也就是说客户端第二次握手的包后它的 TCP 连接状态就为 established 表示该连接已经建立. 那么如果第三次握手中的 ACK 包丢失的情况下, 客户端向服务端端发送数据, 服务端将以 RST 包响应, 方能感知到服务端的错误.
