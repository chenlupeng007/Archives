TCP 协议想要解决的一个问题就是双向通信, 也就是也就是双方都是发送方和接收方. 这就需要双方都知道彼此的 IP 和端口号. 在通信开始之前, 客户端知道通信双方的 IP 和端口号, 但是服务器却不知道. 另一个需要解决的问题是改变 UDP 这种只要有一个包丢失, 就要重发的低效特性, 使得通信变得更为可靠.

为此通信正式开始之前, 客户端和服务器准备好所需要的通信控制信息. 这个准备的过程需要经过所谓的"三次握手".

第一次握手: 客户端首先发送一个包, 这个包标头带有通信双方的端口号, 双方的 IP 地址则存在 IP 包的标头, SYN 设置为 1(告诉对方这是连接阶段, 相应的 Fin 为 1 则表示断开阶段); 还随机生成一个初始序列值 seq=x(相当于告诉对方数据开始于 x 处); ack=0(ack = y, 表示 y 之前的我都收到了); 客户端窗口值(告诉对方我的缓冲器还可容纳这么多字节).

第二次握手: 数据包到达服务器后, 服务器可以得到客户端的 IP, 端口, 序列初始值 seq, 窗口等信息. 然后构造一个 SYN = 1; seq = y(随机生成, 需要告知自己数据的初始位置, 因为双发都需要收发数据); ack = x+1(告诉对方 x+1 位置之前的我都收到了); 服务器窗口值. 并期待对方返回 ack = y+1 的包.

第三次握手: 这个包到达客户端后, 客户端就得到了服务器的序列初始值, 窗口号, 这样客户单所需的服务器的全部信息就都准备完毕了, 最后客户端返回 ack = y+1 的包, 并转入 established 状态. 如果这个包到达了服务器那么服务器也准备完成, 进入 established 状态. 如果这个包丢了, 服务器重发几次, 第二次握手的包, 最后发起结束请求. 即使客户端发来了数据也不会回应了.

> seq = x 的包发出后, 如果没有收到一个 ack > x 的包, 会重发几次, 尝试几次后不行, 套接字返回请求失败.
> 如果收到 ack = x 的包, 那么之后接收到 seq < x 的包则会丢弃, 这样就不用担心重发的包到达.

连接创建好了, 则进入通信阶段. 应用程序调用 write(), 把数据交给协议栈发送, 读取数据则是 read() 函数.

一般 web 服务器在知道客户端已经接收到全部相应后, 调用 close() 进入断开阶段. 断开则经历了四次
挥手. 整个过程如下图:

<center>
  <img src='./TCP.png' >
</center>
