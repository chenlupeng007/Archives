## Understanding Internet Protocol
全球的计算机通过光缆, 电缆, 双绞线, 无线电波等方式连接起来, 组成了网络, 这些将计算机连接起来的实体位于实体层. 实体层主要规定网络的一些电气特性, 作用是负责传送 0 和 1 的电信号.

计算机上安装的网卡负责发送, 接收这些电信号. 为了解读电信号, 需要规定0和1的分组方式, 链接层的协议负责规定这些. 每块网卡出厂的时候, 都会带有一个全世界独一无二的 MAC 地址, 长度是 48 个二进制位, 通常用 12 个十六进制数表示, 前6个十六进制数是厂商编号, 后6个是该厂商的网卡流水号.

<Center>
  <img src='http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052906.png' />
</Center>

以链接层的以太网协议为例, 以太网规定的一组电信号(数据包), 叫做"帧". 每一帧分成两个部分: 标头(Head)和数据(Data). 标头包含数据包的一些说明项, 比如发送者和接受者的 MAC 地址(假设已经获得了对方的 MAC 地址); 数据则是数据包的具体内容. 标头的长度固定为 18 字节, 数据的长度为 46~1500 字节. 因此, 整个"帧"最短为 64(18+46) 字节，最长为 1518(18+1500) 字节. 如果数据过长，就必须分割成多个帧进行发送.

<Center>
  <img src='http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052904.png' />
</Center>

在知道通讯双方的地址的前提下, 理论上只要想全球所有计算机发送数据包, 每台计算机根据包中接收者的 MAC 地址就可以判断是否接收这个包, 从而达到通讯的目的, 显然这种效率低下的方式并不可取. 因此互联网是分成了很多子网, 再将子网连成更大的网络. 为了区分哪些 MAC 地址属于同一个子网络, 哪些不是, 诞生了网络层. 它引入 IP 地址, 使得我们能够区分不同的计算机是否属于同一个子网络. 那么它是如何做到的呢?

目前广泛采用的是 IPv4, 这个版本规定, 网络地址由 32 个二进制位组成. 习惯上, 我们用分成四段的十进制数表示 IP 地址. 互联网上的每一台计算机, 都会分配到一个 IP 地址, 这个地址分成两个部分, 前一部分代表网络, 后一部分代表主机. 子网掩码则被用来确定哪一部份是网络部分, 以 172.16.254.1为例, 子网掩码如果为 11111111.11111111.11111111.00000000, 则网络部分是前 24 位，主机部分是后 8 位. 将两个 IP 地址与子网掩码分别进行按位取 AND 运算, 如果结果相同就表明它们在同一个子网络中, 否则就不是.

<Center>
  <img src='http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052908.png' />
</Center>

数据先封装成 IP 数据包, 然后将 IP 数据包作为以太网协议的数据部分交由以太网进行传输. 一个 IP 数据包的"标头"部分的长度为 20~60 字节, 整个数据包的总长度最大为 65,535 字节. 因此, 理论上，一个IP数据包的"数据"部分，最长为65,515字节. 而以太网数据包的数据部分, 最长只能容纳 1500 字节, 因此, 如果 IP 数据包超过了 1500 字节, 它就需要分割成几个以太网数据包来发送.

<Center>
  <img src='http://www.ruanyifeng.com/blogimg/asset/201205/bg2012052910.png' />
</Center>

至此, 每台计算机上都有一个 IP 地址和 MAC 地址. 链接层(以太网协议)可以用广播的方式实现同一个子网下的计算机之间的通信. 再加上网络层(IP协议)就可以让互联网中任意两台计算机进行通信. 下面将更详细描述如何做到这一点.

为了达到这一目的, 需要发送方和接收方双方的 IP 地址和 MAC 地址. 当一台计算机开机后它首先要获得一个 IP 地址, 这样接收方的 IP 和 MAC 地址就都有了. 那么如何获得本机的 IP 地址呢? 现在通常是以 [DHCP 协议](./DHCP.md) 来动态分配的(通过 DHCP 还能够获得子网掩码, 网关地址, DNS 服务器等参数). 当上层的协议想通过 IP 协议来通信的时候, 会交给 IP 协议对方的 IP 地址(例如, HTTP 通过域名解析获得对方的 IP 地址), 因此在网际层上可以认为已经获得了对方的 IP 地址. 之后通过上文的 IP 与子网掩码按位取与运算可以判断出是否位于同一个子网下. 如果位于同一子网则用 [ARP 协议](./ARP.md)获得对方的 MAC 地址, 否则将接收方 MAC 地址设为网关的 MAC 地址, 也就是说将包发给网关. 网关将作为发送方代理发送这个数据包至更外层的网络.

|      场景      |     数据包地址填写方式      |
| -------------- | --------------------------- |
|  同一个子网络  | 对方的MAC地址，对方的IP地址 |
| 非同一个子网络 | 网关的MAC地址，对方的IP地址 |

到了网络层, 我们已经可以在互联网中任意两台计算机进行通信了. 接下来的问题是, 同一台主机上有许多程序都需要用到网络, 比如浏览器和聊天程序. 当一个数据包从互联网上发来的时候, 怎么知道它是传给浏览器还是聊天程序的? 操作系统为这些程序分配端口号, 端口是 0~65535 之间的一个整数, 正好 16 个二进制位. 0 到 1023 的端口被系统占用, 用户程序只能选用大于 1023 的端口. **传输层的功能, 就是建立"端口到端口"的通信. 相比之下, "网络层"的功能是建立"主机到主机"的通信**.

传输层主要有两个协议 UDP 和 TCP. UDP 协议的优点是比较简单, 容易实现, 但是缺点是可靠性较差, 一旦数据包发出, 无法知道对方是否收到. 为了解决这个问题, 提高网络传输的可靠性, TCP 协议就诞生了. 这个协议非常复杂, 但可以近似认为, 它就是有确认机制的 UDP 协议, 每发出一个数据包都要求确认. 如果有一个数据包遗失, 就收不到确认, 发出方就知道有必要重发这个数据包了. 因此, TCP 协议能够确保数据不会遗失. 它的缺点是过程复杂, 实现困难, 消耗较多的资源. TCP 数据包和 UDP 数据包一样, 都是内嵌在IP数据包的"数据"部分.

应用程序收到"传输层"返回的数据, 接下来就要进行解读. 应用层的作用, 就是规定应用程序的数据格式.

计算机开机以后, 经由 DHCP 动态分配获得 IP 地址, 子网掩码, 网关地址, DNS 服务器等参数.

在浏览器地址栏上输入 `www.google.com`. 浏览器会解析 URL, 知道应用层的协议是 HTTP, Web 服务器域名是 `www.google.com`, 一般还会有请求文件的路径名. 浏览器会根据 HTTP 协议构造请求消息, 请求消息就是浏览器要委托协议栈进行发送的数据. 例如:

```
GET / HTTP/1.1
Host: www.google.com
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
Cookie: ... ...
```

有了要传输的数据, 还需要接收方的 IP 和 端口. 应用层协议一般有默认端口, 这里 HTTP 默认端口是 80. 浏览器将服务器域名作为参数调用 Socket 库中的 [DNS](./DNS.md) 解析器得到 IP 地址. 接着浏览器需要调用 Socket 库中的函数, 委托协议栈发送消息.

至此, 还需要本方的端口号. 浏览器调用 socket 函数创建一个套接字, 类似这样 <描述符> = socket(<使用 IPv4>, <流模式>, ...). 返回的是一个描述符, 当打开了多个浏览器窗口, 同时访问两台浏览器是, 对与浏览器也就有了两个套接字, 描述符就可用来区分不同的套接字. 浏览器才知道要跟哪个套接字打交道. 套接字可以用(IP地址: 端口号)表示. 更具体地, 创建套接字时, 操作系统分配内存空间, 并将所需的通信控制信息(例如双方 IP, 端口号, 通信进行状态等等)写入内存.

之后, 应用程序将数据委托协议栈进行传输, HTTP 主要使用 [TCP 协议](./TCP.md) 进行传输.
